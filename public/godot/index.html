<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no">
	<title>Autopilot Visualizer</title>
	<style type="text/css">
		body {
			touch-action: none;
			margin: 0;
			border: 0 none;
			padding: 0;
			text-align: center;
			background-color: #1a1a1c;
			overflow: hidden;
		}

		#canvas {
			display: block;
			margin: 0;
			color: white;
		}

		#canvas:focus {
			outline: none;
		}

		/* Status/loading elements - hidden for React integration */
		#status, #status-progress, #status-progress-inner, 
		#status-indeterminate, #status-notice {
			display: none !important;
		}
	</style>
	
	<!-- ================================================================
	     GODOT BRIDGE - React <-> Godot Communication Layer
	     This MUST be loaded before the Godot engine initializes
	     ================================================================ -->
	<script type="text/javascript">
	(function() {
		'use strict';

		// Message queue for React -> Godot communication
		const messageQueue = [];

		// Event listeners for Godot -> React communication
		const eventListeners = {};

		// State tracking
		let godotReady = false;
		let carLoaded = false;
		let currentModelId = null;

		function init() {
			console.log('[GodotBridge] Initializing...');

			// Create the global godot object
			window.godot = {
				// Send a message to Godot
				sendMessage: function(message) {
					if (!message || typeof message !== 'object') {
						console.error('[GodotBridge] Invalid message:', message);
						return false;
					}
					if (!message.type) {
						console.error('[GodotBridge] Message missing type:', message);
						return false;
					}
					console.log('[GodotBridge] Queueing message:', message.type);
					messageQueue.push(JSON.stringify(message));
					return true;
				},

				loadScene: function(modelId) {
					return this.sendMessage({ type: 'load_scene', modelId: modelId });
				},

				setTexture: function(dataUrl) {
					return this.sendMessage({ type: 'set_texture', texture: dataUrl });
				},

				setCarState: function(state) {
					return this.sendMessage({ type: 'set_car_state', state: state });
				},

				setPaint: function(colorName) {
					return this.sendMessage({ type: 'set_paint', color: colorName });
				},

				setSkin: function(skinName) {
					return this.sendMessage({ type: 'set_skin', skin: skinName });
				},

				setCameraAngle: function(horizontal, vertical, distance) {
					return this.sendMessage({
						type: 'set_camera_angle',
						horizontal: horizontal,
						vertical: vertical,
						distance: distance || -1
					});
				},

				setCameraPreset: function(preset) {
					return this.sendMessage({ type: 'set_camera_preset', preset: preset });
				},

				setAutoRotate: function(enabled) {
					return this.sendMessage({ type: 'set_camera_auto_rotate', enabled: enabled });
				},

			resetCamera: function() {
				return this.sendMessage({ type: 'reset_camera' });
			},

			setPlateRegion: function(region) {
				return this.sendMessage({ type: 'set_plate_region', region: region });
			},

				// Called by Godot to get next pending message
				getPendingMessage: function() {
					if (messageQueue.length === 0) return null;
					return messageQueue.shift();
				},

				getPendingMessageCount: function() {
					return messageQueue.length;
				},

				// Called by Godot to send events back to React
				onGodotMessage: function(event) {
					if (!event || !event.type) {
						console.warn('[GodotBridge] Invalid event from Godot:', event);
						return;
					}
					console.log('[GodotBridge] Received from Godot:', event.type, event.data);

					switch (event.type) {
						case 'godot_ready': godotReady = true; break;
						case 'car_loaded': 
							carLoaded = true;
							currentModelId = event.data?.modelId;
							break;
						case 'error':
							console.error('[GodotBridge] Godot error:', event.data?.message);
							break;
					}

					// Notify listeners
					(eventListeners[event.type] || []).forEach(cb => { try { cb(event.data); } catch(e) {} });
					(eventListeners['*'] || []).forEach(cb => { try { cb(event); } catch(e) {} });

					// Post to parent window (for iframe)
					if (window.parent && window.parent !== window) {
						try { window.parent.postMessage(event, '*'); } catch(e) {}
					}
				},

				on: function(eventType, callback) {
					if (!eventListeners[eventType]) eventListeners[eventType] = [];
					eventListeners[eventType].push(callback);
					return function() {
						const idx = eventListeners[eventType].indexOf(callback);
						if (idx !== -1) eventListeners[eventType].splice(idx, 1);
					};
				},

				off: function(eventType, callback) {
					const listeners = eventListeners[eventType];
					if (!listeners) return;
					const idx = listeners.indexOf(callback);
					if (idx !== -1) listeners.splice(idx, 1);
				},

				isReady: function() { return godotReady; },
				isCarLoaded: function() { return carLoaded; },
				getCurrentModelId: function() { return currentModelId; },
				clearQueue: function() { messageQueue.length = 0; },
				reset: function() {
					messageQueue.length = 0;
					godotReady = false;
					carLoaded = false;
					currentModelId = null;
				}
			};

		// Listen for postMessage from parent (React app)
		window.addEventListener('message', function(event) {
			if (event.data && event.data.type) {
				console.log('[GodotBridge] Received postMessage:', event.data.type);
				
				// Handle resize request from parent (function defined later in body script)
				if (event.data.type === 'resize' || event.data.type === 'force_resize') {
					if (typeof window.adjustCanvasDimensions === 'function') {
						window.adjustCanvasDimensions();
					}
					return;
				}
				
				window.godot.sendMessage(event.data);
			}
		});

			// Godot-compatible aliases (SceneManager.gd uses these)
			window.godot_sendMessage = function(jsonStr) {
				try {
					const event = typeof jsonStr === 'string' ? JSON.parse(jsonStr) : jsonStr;
					window.godot.onGodotMessage(event);
					return true;
				} catch(e) {
					console.error('[GodotBridge] godot_sendMessage error:', e);
					return false;
				}
			};

			window.godot_pendingMessagesCount = function() {
				return messageQueue.length;
			};

			window.godot_getPendingMessage = function() {
				if (messageQueue.length === 0) return '';
				return messageQueue.shift();
			};

		console.log('[GodotBridge] Ready. Use window.godot to communicate with Godot.');
	}

	// Initialize immediately
	init();
})();
	</script>
	
	<!-- Load Godot Engine (defines the Engine class) -->
	<script type="text/javascript" src="index.js"></script>
	
</head>
<body>
	<canvas id="canvas">
		HTML5 canvas appears to be unsupported in the current browser.<br />
		Please try updating or use a different browser.
	</canvas>

	<div id="status" style="display: none;">
		<div id="status-progress" style="display: none;">
			<div id="status-progress-inner"></div>
		</div>
		<div id="status-indeterminate" style="display: none;">
			<div></div><div></div><div></div><div></div>
			<div></div><div></div><div></div><div></div>
		</div>
		<div id="status-notice" style="display: none;"></div>
	</div>

	<script type="text/javascript">//<![CDATA[
		var engine = new Engine;
		var setStatusMode;
		var setStatusNotice;

		(function() {
			const EXECUTABLE_NAME = 'index';
			
			// Support .pck URL from query parameter (Supabase CDN)
			const urlParams = new URLSearchParams(window.location.search);
			const pckFromUrl = urlParams.get('pck');
			const MAIN_PACK = pckFromUrl || 'index.pck';
			console.log('[Godot] Using pack file:', pckFromUrl ? 'Supabase CDN' : 'local');

			const INDETERMINATE_STATUS_STEP_MS = 100;

			var canvas = document.getElementById('canvas');
			var statusProgress = document.getElementById('status-progress');
			var statusProgressInner = document.getElementById('status-progress-inner');
			var statusIndeterminate = document.getElementById('status-indeterminate');
			var statusNotice = document.getElementById('status-notice');

			var initializing = true;
			var statusMode = 'hidden';

			var animationCallbacks = [];
			function animate(time) {
				animationCallbacks.forEach(callback => callback(time));
				requestAnimationFrame(animate);
			}
			requestAnimationFrame(animate);

			var resizeTimeout = null;
			var lastPixelRatio = window.devicePixelRatio || 1;
			
			// Make this global so bridge can call it
			window.adjustCanvasDimensions = function() {
				var scale = window.devicePixelRatio || 1;
				var width = window.innerWidth;
				var height = window.innerHeight;
				
				// Only update if dimensions actually changed
				var newWidth = Math.floor(width * scale);
				var newHeight = Math.floor(height * scale);
				
				if (canvas.width !== newWidth || canvas.height !== newHeight) {
					canvas.width = newWidth;
					canvas.height = newHeight;
					canvas.style.width = width + 'px';
					canvas.style.height = height + 'px';
					console.log('[Godot] Canvas resized:', newWidth, 'x', newHeight, 'scale:', scale);
				}
			};
			
			// Debounced resize handler for smoother resizing
			function debouncedResize() {
				if (resizeTimeout) clearTimeout(resizeTimeout);
				resizeTimeout = setTimeout(window.adjustCanvasDimensions, 100);
			}
			
			// Check for pixel ratio changes (dev tools, display changes)
			function checkPixelRatioChange() {
				var currentRatio = window.devicePixelRatio || 1;
				if (currentRatio !== lastPixelRatio) {
					lastPixelRatio = currentRatio;
					window.adjustCanvasDimensions();
				}
			}
			
			// Initial resize with multiple attempts to ensure correct dimensions
			// (iframe may not have final size immediately)
			window.adjustCanvasDimensions();
			setTimeout(window.adjustCanvasDimensions, 50);
			setTimeout(window.adjustCanvasDimensions, 150);
			setTimeout(window.adjustCanvasDimensions, 300);
			setTimeout(window.adjustCanvasDimensions, 500);
			setTimeout(window.adjustCanvasDimensions, 1000);
			
			window.addEventListener('resize', debouncedResize);
			
			// Also handle visibility changes and focus (can affect pixel ratio)
			document.addEventListener('visibilitychange', function() {
				if (!document.hidden) {
					setTimeout(window.adjustCanvasDimensions, 100);
				}
			});
			
			// Check pixel ratio periodically (catches dev tools open/close)
			setInterval(checkPixelRatioChange, 500);

			setStatusMode = function setStatusMode(mode) {
				if (statusMode === mode || !initializing)
					return;
				[statusProgress, statusIndeterminate, statusNotice].forEach(elem => {
					elem.style.display = 'none';
				});
				animationCallbacks = animationCallbacks.filter(function(value) {
					return (value != animateStatusIndeterminate);
				});
				switch (mode) {
					case 'progress':
						statusProgress.style.display = 'block';
						break;
					case 'indeterminate':
						statusIndeterminate.style.display = 'block';
						animationCallbacks.push(animateStatusIndeterminate);
						break;
					case 'notice':
						statusNotice.style.display = 'block';
						break;
					case 'hidden':
						break;
					default:
						throw new Error('Invalid status mode');
				}
				statusMode = mode;
			}

			function animateStatusIndeterminate(ms) {
				var i = Math.floor(ms / INDETERMINATE_STATUS_STEP_MS % 8);
				if (statusIndeterminate.children[i].style.borderTopColor == '') {
					Array.prototype.slice.call(statusIndeterminate.children).forEach(child => {
						child.style.borderTopColor = '';
					});
					statusIndeterminate.children[i].style.borderTopColor = '#dfdfdf';
				}
			}

			setStatusNotice = function setStatusNotice(text) {
				while (statusNotice.lastChild) {
					statusNotice.removeChild(statusNotice.lastChild);
				}
				var lines = text.split('\n');
				lines.forEach((line) => {
					statusNotice.appendChild(document.createTextNode(line));
					statusNotice.appendChild(document.createElement('br'));
				});
			};

			// Send real progress to React parent
			engine.setProgressFunc((current, total) => {
				if (total > 0) {
					var progress = current / total;
					// Notify React of loading progress
					if (window.parent && window.parent !== window) {
						window.parent.postMessage({ type: 'godot_progress', progress: progress }, '*');
					}
					statusProgressInner.style.width = progress * 100 + '%';
					setStatusMode('progress');
					if (current === total) {
						setTimeout(() => {
							setStatusMode('indeterminate');
						}, 500);
					}
				} else {
					setStatusMode('indeterminate');
				}
			});

			function displayFailureNotice(err) {
				var msg = err.message || err;
				console.error('[Godot] Error:', msg);
				setStatusNotice(msg);
				setStatusMode('notice');
				initializing = false;
				// Notify React of error
				if (window.parent && window.parent !== window) {
					window.parent.postMessage({ type: 'godot_error', message: msg }, '*');
				}
			};

			if (!Engine.isWebGLAvailable()) {
				displayFailureNotice('WebGL not available');
			} else {
				setStatusMode('indeterminate');
				engine.setCanvas(canvas);
				engine.startGame(EXECUTABLE_NAME, MAIN_PACK).then(() => {
					setStatusMode('hidden');
					initializing = false;
					console.log('[Godot] Engine started successfully');
					// Notify React that engine is ready
					if (window.parent && window.parent !== window) {
						window.parent.postMessage({ type: 'godot_ready', version: '1.0' }, '*');
					}
				}, displayFailureNotice);
			}
		})();
	//]]></script>
</body>
</html>

